#
# This file is distributed under the MIT License. See LICENSE.md for details.
#

#
# Accept arguments (only paths for now)
#
import argparse

parser = argparse.ArgumentParser(
    description="A code generator to help making abi test artifacts"
)

parser.add_argument(
    "template_directory",
    type=str,
    help="Specifies the directory where the templates are located",
)
parser.add_argument(
    "config_directory",
    type=str,
    help="Specifies the directory where the configs are located",
)
parser.add_argument(
    "output_directory",
    type=str,
    help="Specifies the directory where to output the results to",
)

arguments = parser.parse_args()

#
# Load configs
#
import yaml

with open(str(arguments.config_directory) + "/architectures.yml", "r") as file:
    architectures = yaml.safe_load(file)
with open(str(arguments.config_directory) + "/common.yml", "r") as file:
    config = yaml.safe_load(file)
with open(str(arguments.config_directory) + "/functions.yml", "r") as file:
    functions = yaml.safe_load(file)

#
# Setup Jinja
#
import jinja2, os

jinja_loader = jinja2.FileSystemLoader(str(arguments.template_directory))
jinja_environment = jinja2.Environment(
    block_start_string="/*{",
    block_end_string="}*/",
    variable_start_string="/*(",
    variable_end_string=")*/",
    comment_start_string="/*#",
    comment_end_string="#*/",
    loader=jinja_loader,
)


def render_helper(template_name: str, output_directory: str, variable_dictionary={}):
    jinja_template = jinja_environment.get_template(template_name + ".jinja_template")

    result_dir = str(arguments.output_directory)
    result_path = result_dir + "/" + output_directory + "/" + template_name
    os.makedirs(os.path.dirname(result_path), exist_ok=True)
    with open(result_path, "w") as file:
        file.write(jinja_template.render(variable_dictionary))


def fill_a_register(architecture, location, offset, register):
    local_dictionary = {
        "location": location,
        "offset": offset,
        "register": register,
    }

    jinja_template = jinja2.Environment().from_string(
        architecture["templates"]["fill_a_register"]
    )
    return jinja_template.render(local_dictionary)


def setup_registers(architecture):
    result = str("")
    for index, register in enumerate(architecture["register_list"]):
        location = "randomized_state"
        offset = index * architecture["register_size"]
        current = fill_a_register(architecture, location, offset, register)
        result = result + current + "\n"
    return result


def setup_stack(architecture):
    register_size = architecture["register_size"]
    register_offset = len(architecture["register_list"]) * register_size
    total_offset = register_offset + config["stack_byte_count"]

    result = str("")
    for offset in range(register_offset, total_offset, register_size):
        stack_helper_dictionary = {
            "register": architecture["register_list"][0],
            "fill_a_register": fill_a_register(
                architecture,
                "randomized_state",
                offset,
                architecture["register_list"][0],
            ),
        }
        jinja_template = jinja2.Environment().from_string(
            architecture["templates"]["push_to_stack"]
        )
        result = result + jinja_template.render(stack_helper_dictionary) + "\n"

    return result


def call_a_function(architecture, name: str):
    jinja_template = jinja2.Environment().from_string(
        architecture["templates"]["call_a_function"]
    )
    return jinja_template.render({"function_name": name})


def restore_stack(architecture):
    jinja_template = jinja2.Environment().from_string(
        architecture["templates"]["restore_stack"]
    )
    return jinja_template.render({"stack_size": config["stack_byte_count"]})


def fix_return_address(architecture):
    jinja_template = jinja2.Environment().from_string(
        architecture["templates"]["fix_return_address"]
    )
    return jinja_template.render({"stack_size": config["stack_byte_count"]})


def return_from_function(architecture):
    jinja_template = jinja2.Environment().from_string(
        architecture["templates"]["return_from_function"]
    )
    return jinja_template.render({"stack_size": config["stack_byte_count"]})


def asm(input: str):
    return '"' + '\\n"\n      "'.join(input.splitlines()) + '\\n"'


#
# helper values
#
generation_notice = """/*
 * This file was autogenerated. DO NOT MODIFY!
 * It is distributed under the MIT License. See LICENSE.md for details.
 */"""

#
# functions
#
function_dictionary = {
    "generation_notice": generation_notice,
    "structs": functions["helper_structs"],
    "argument_functions": functions["argument_tests"],
    "return_value_functions": functions["small_return_value_tests"],
}
render_helper("functions.h", "include", function_dictionary)
render_helper("functions.c", "source", function_dictionary)

#
# description
#
for architecture_name, architecture in architectures.items():
    dictionary = {
        "generation_notice": generation_notice,
        "architecture_name": architecture_name,
        "stack_byte_count": config["stack_byte_count"],
        "lfsr_seed": config["lfsr_seed"],
        "iteration_count": config["iteration_count"],
        "register_type": architecture["register_type"],
        "register_size": architecture["register_size"],
        "register_list": architecture["register_list"],
        "register_count": len(architecture["register_list"]),
        "argument_functions": functions["argument_tests"],
        "return_value_functions": functions["small_return_value_tests"],
        "fill_stack_with_random_data": asm(setup_stack(architecture)),
        "fill_registers_with_random_data": asm(setup_registers(architecture)),
        "call_a_function": lambda name, a=architecture: asm(call_a_function(a, name)),
        "restore_stack": asm(restore_stack(architecture)),
        "fix_return_address": asm(fix_return_address(architecture)),
        "return_from_function": asm(return_from_function(architecture)),
    }

    combined = dictionary["register_count"] * dictionary["register_size"]
    dictionary["generated_byte_count"] = dictionary["stack_byte_count"] + combined

    render_helper(
        "describe_functions.c",
        "source/" + architecture_name,
        dictionary,
    )
