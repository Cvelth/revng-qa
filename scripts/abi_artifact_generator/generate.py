#
# This file is distributed under the MIT License. See LICENSE.md for details.
#

import argparse
import os
import sys

import jinja2
import yaml


def accept_arguments():
    parser = argparse.ArgumentParser(
        description="A code generator to help making abi test artifacts"
    )

    parser.add_argument(
        "template_directory",
        type=str,
        help="Specifies the directory where the templates are located",
    )
    parser.add_argument(
        "config_directory",
        type=str,
        help="Specifies the directory where the configs are located",
    )
    parser.add_argument(
        "output_directory",
        type=str,
        help="Specifies the directory where to output the results to",
    )
    parser.add_argument(
        "--split_file_mode",
        action="store_true",
        help="When set to true, each test function generates a separate binary"
    )

    return parser.parse_args()


def load_configs(arguments):
    with open(str(arguments.config_directory) + "/architectures.yml", "r") as file:
        architectures = yaml.safe_load(file)
    with open(str(arguments.config_directory) + "/common.yml", "r") as file:
        config = yaml.safe_load(file)
    with open(str(arguments.config_directory) + "/functions.yml", "r") as file:
        functions = yaml.safe_load(file)
    return (architectures, config, functions)


def setup_jinja_environment(arguments):
    jinja_loader = jinja2.FileSystemLoader(str(arguments.template_directory))
    return jinja2.Environment(
        block_start_string="/*{",
        block_end_string="}*/",
        variable_start_string="/*(",
        variable_end_string=")*/",
        comment_start_string="/*#",
        comment_end_string="#*/",
        loader=jinja_loader,
    )


def render_helper(env, template_name: str, result_path: str, variable_dictionary={}):
    jinja_template = env.get_template(template_name + ".jinja_template")

    os.makedirs(os.path.dirname(result_path), exist_ok=True)
    with open(result_path, "w") as file:
        file.write(jinja_template.render(variable_dictionary))


def register_type(register_size: str):
    if register_size == 1:
        return "uint8_t"
    elif register_size == 2:
        return "uint16_t"
    elif register_size == 4:
        return "uint32_t"
    elif register_size == 8:
        return "uint64_t"
    else:
        raise Exception("unsupported register size")


def intel_register_type(register_size: str):
    if register_size == 1:
        return "byte"
    elif register_size == 2:
        return "word"
    elif register_size == 4:
        return "dword"
    elif register_size == 8:
        return "qword"
    else:
        raise Exception("unsupported register size")


def get_generation_notice():
    return """/* This file was autogenerated. DO NOT MODIFY!
 * It is distributed under the MIT License. See LICENSE.md for details.
 */"""


def render_functions_impl(jinja_environment, path: str, dictionary, out_dir: str):
    filename = "functions.h"
    result_path = out_dir + "/" + path + filename
    render_helper(jinja_environment, filename, result_path, dictionary)

    filename = "functions.inc"
    result_path = out_dir + "/" + path + filename
    render_helper(jinja_environment, filename, result_path, dictionary)


def render_functions(jinja_environment, config, functions, out_dir: str, split_file_mode: bool):
    dictionary = {
        "generation_notice": get_generation_notice(),
        "maximum_argument_count": config["maximum_argument_count"],
        "maximum_argument_size": config["maximum_argument_size"],
        "structs": functions["structs"],
        "packed_structs": functions["packed_structs"],
        "argument_functions": functions["argument_tests"],
        "return_value_functions": functions["return_value_tests"],
    }

    if not split_file_mode:
        render_functions_impl(jinja_environment, "", dictionary, out_dir)
    else:
        dictionary["return_value_functions"] = {}
        for function, arguments in functions["argument_tests"].items():
            dictionary["argument_functions"] = { function: arguments }
            path = "split/" + function + "/"
            render_functions_impl(jinja_environment, path, dictionary, out_dir)

        dictionary["argument_functions"] = {}
        for function, return_value in functions["return_value_tests"].items():
            dictionary["return_value_functions"] = { function: return_value }
            path = "split/" + function + "/"
            render_functions_impl(jinja_environment, path, dictionary, out_dir)


def render_function_description_impl(jinja_environment, path: str, dictionary, out_dir: str):
    filename = "constants.h"
    result_path = out_dir + "/" + path + filename
    render_helper(jinja_environment, filename, result_path, dictionary)

    filename = "decoders.inc"
    result_path = out_dir + "/" + path + filename
    render_helper(jinja_environment, filename, result_path, dictionary)

    filename = "setup.inc"
    result_path = out_dir + "/" + path + filename
    render_helper(jinja_environment, filename, result_path, dictionary)


def render_function_description(jinja_env, architectures, config, functions, out_dir, split_file_mode: bool):
    for architecture_name, architecture in architectures.items():
        dictionary = {
            "generation_notice": get_generation_notice(),
            "architecture_name": architecture_name,
            "stack_byte_count": config["stack_byte_count"],
            "lfsr_seed": config["lfsr_seed"],
            "iteration_count": config["iteration_count"],
            "maximum_argument_count": config["maximum_argument_count"],
            "maximum_argument_size": config["maximum_argument_size"],
            "register_type": register_type(architecture["register_size"]),
            "intel_register_type": intel_register_type(architecture["register_size"]),
            "register_size": architecture["register_size"],
            "register_list": architecture["register_list"],
            "register_count": len(architecture["register_list"]),
            "argument_functions": functions["argument_tests"],
            "return_value_functions": functions["return_value_tests"],
        }

        combined_registers = dictionary["register_count"] * dictionary["register_size"]
        dictionary["generated_byte_count"] = dictionary["stack_byte_count"] + combined_registers
        assert dictionary["generated_byte_count"] % dictionary["register_size"] == 0

        if not split_file_mode:
            function_count = len(functions["argument_tests"]) + len(functions["return_value_tests"])
            dictionary["function_count"] = function_count
            render_function_description_impl(jinja_env, architecture_name + "/", dictionary, out_dir)

        else:
            dictionary["function_count"] = 1

            dictionary["return_value_functions"] = {}
            for function, arguments in functions["argument_tests"].items():
                dictionary["argument_functions"] = { function: arguments }
                path = "split/" + function + "/" + architecture_name + "/"
                render_function_description_impl(jinja_env, path, dictionary, out_dir)

            dictionary["argument_functions"] = {}
            for function, return_value in functions["return_value_tests"].items():
                dictionary["return_value_functions"] = { function: return_value }
                path = "split/" + function + "/" + architecture_name + "/"
                render_function_description_impl(jinja_env, path, dictionary, out_dir)


def main():
    arguments = accept_arguments()
    architectures, config, functions = load_configs(arguments)

    environment = setup_jinja_environment(arguments)

    out_dir = str(arguments.output_directory)
    render_functions(environment, config, functions, out_dir, arguments.split_file_mode)
    render_function_description(environment, architectures, config, functions, out_dir, arguments.split_file_mode)

    return 0


if __name__ == "__main__":
    sys.exit(main())
