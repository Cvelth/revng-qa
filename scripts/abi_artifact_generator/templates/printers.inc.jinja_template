/*#-
This template file is distributed under the MIT License. See LICENSE.md for details.
#*/

/*(- generation_notice )*/

#include "../common.h"
#include "../functions.h"
#include "../types.h"

_Static_assert(sizeof(uint8_t) == 1, "A type with size == 1 is required.");
#define MAKE_PRINT_HELPER(TYPE, POINTER, RESULT) \
  typedef union {                                \
    TYPE v;                                      \
    uint8_t a[sizeof(TYPE)];                     \
  } printing_##RESULT;                           \
  printing_##RESULT *RESULT = (printing_##RESULT *) (POINTER)

#define PRINT_BYTES(TYPE, HELPER)                          \
  do {                                                     \
    printf("[ ");                                          \
    for (unsigned i = 0; i < sizeof(TYPE) - 1; ++i)        \
      printf("0x%.2hhx, ", (HELPER)->a[i]);                \
    printf("0x%.2hhx ]\n", (HELPER)->a[sizeof(TYPE) - 1]); \
  } while (0)

#define PRINT_A_WORD(LOCATION, NAME)                          \
  do {                                                        \
    typedef uint8_t single_word[/*( register_size )*/];       \
    MAKE_PRINT_HELPER(/*( register_type )*/,                  \
                      (LOCATION),                             \
                      word_printing_helper);                  \
    printf("        - Name: \"%s\"\n          "               \
           "Value: 0x%0/*( register_size * 2 )*/zx\n",        \
           NAME,                                              \
           word_printing_helper->v);                          \
    printf("          Bytes: ");                              \
    PRINT_BYTES(/*( register_type )*/, word_printing_helper); \
  } while (0)

#define PRINT_A_REGISTER(LOCATION, INDEX)                     \

static char *register_list[/*( register_count )*/] = {
  /*{ for register in register_list -}*/
  /*( "\"" + register + "\"" -)*/
  /*{- if not loop.last -}*/ , /*{ endif -}*/
  /*{- endfor }*/
};

static void print_stored_state(location_pointer pointer,
                               _Bool has_stack_pointer) {
  uint32_t index_offset = 0;
  if (has_stack_pointer) {
    puts("      StackPointer:");
    PRINT_A_WORD(pointer.words, "/*( stack_pointer )*/");
  }

  puts("      Registers:");
  for (uint32_t index = 0; index < /*( register_count )*/; ++index)
    PRINT_A_WORD(pointer.words + index + 1, register_list[index]);

  printf("      Stack: ");
  typedef uint8_t stack_state[/*( stack_byte_count )*/];
  stack_state *state_ptr = (stack_state *) (pointer.words + /*( register_count + 1 )*/);
  MAKE_PRINT_HELPER(stack_state, state_ptr, stack_printing_helper);
  PRINT_BYTES(stack_state, stack_printing_helper);
}

#define PRINT(TYPE, POINTER)                        \
  do {                                              \
    printf("      - Type: " #TYPE " # size = %zu\n" \
           "        Bytes: ",                       \
           sizeof(TYPE));                           \
    MAKE_PRINT_HELPER(TYPE, POINTER, local_helper); \
    PRINT_BYTES(TYPE, local_helper);                \
  } while (0)

#define POINTER(TYPE, POINTER)                        \
  do {                                                \
    printf("      - Type: " #TYPE " # size = %zu\n"   \
           "        Pointer: 0x%zx\n        Bytes: ", \
           sizeof(TYPE),                              \
           (/*( register_type )*/) POINTER);          \
    MAKE_PRINT_HELPER(TYPE *, POINTER, local_helper); \
    PRINT_BYTES(TYPE *, local_helper);                \
  } while (0)

#define ARGUMENT(TYPE, NAME) \
  do {                                                                         \
    TYPE NAME; (void) NAME;                                                    \
    if (sizeof(TYPE) <= ARGUMENT_SIZE_LIMIT(TYPE, NAME) && !IS_PACKED(TYPE)) { \
      PRINT(TYPE, printable_locations[0].bytes + current_offset);              \
      current_offset += sizeof(TYPE);                                          \
    } else {                                                                   \
      POINTER(TYPE, (printable_locations[0].bytes + current_offset));          \
      current_offset += sizeof(TYPE *);                                        \
    }                                                                          \
  } while (0)

/*{ for name, arguments in argument_functions.items() -}*/
NOINLINE void ABIDEF print_/*( name )*/(void) {
  puts("  - Function: \"/*( "test_" + name )*/\"");

  puts("    StateBeforeTheCall:");
  print_stored_state(randomized_state, 0);

  current_offset = 0;
  puts("    Arguments:");
  /*{- for type in arguments }*/
  ARGUMENT(/*( type )*/, argument_/*( loop.index - 1 )*/);
  /*{- endfor }*/

  puts("");
}

/*{ endfor -}*/

/*{ for name, return_value_type in return_value_functions.items() -}*/
NOINLINE void print_/*( name )*/(void) {
  typedef /*( return_value_type )*/ type;

  puts("  - Function: \"/*( "test_" + name )*/\"");
  puts("    ReturnValueAddress:");
  PRINT(type *, printable_locations[2].words);
  puts("    ReturnValue:");
  PRINT(type, printable_locations[2].words + 1);
  puts("    ExpectedReturnValue:");
  PRINT(type, randomized_state.words);
  puts("    StateAfterTheCall:");
  print_stored_state(printable_locations[0], 1);
  puts("    StateAfterTheReturn:");
  print_stored_state(printable_locations[1], 1);
  puts("");
}

/*{ endfor -}*/

static size_t runtime_endianness_check() {
  size_t i = 1;
  return !*((uint8_t *) &i);
}

int main(void) {
  puts("---");

#ifdef TARGET_x86_64
  puts("TargetArchitecture: x86_64");
#elif TARGET_i386
  puts("TargetArchitecture: x86");
#elif TARGET_aarch64
  puts("TargetArchitecture: aarch64");
#elif TARGET_arm
  puts("TargetArchitecture: arm");
#else
  puts("TargetArchitecture: UNSUPPORTED");
  _Static_assert(0, "unsupported platform architecture");
#endif

#ifdef ENDIANNESS_LITTLE
  assert(!runtime_endianness_check() && "little endianness expected!");
  puts("IsLittleEndian: yes");
#elif defined(ENDIANNESS_BIG)
  assert(runtime_endianness_check() && "big endianness expected!");
  puts("IsLittleEndian: no");
#endif

  puts("Iterations:");
  for (uint32_t index = 0; index < /*( iteration_count )*/; ++index) {
    /*{ for function_name, arguments in argument_functions.items() -}*/
    setup_/*( function_name )*/();
    print_/*( function_name )*/();
    /*{ endfor -}*/
    /*{ for function_name, arguments in return_value_functions.items() -}*/
    setup_/*( function_name )*/();
    print_/*( function_name )*/();
    /*{ endfor }*/
  }

  puts("...");
  return 0;
}
