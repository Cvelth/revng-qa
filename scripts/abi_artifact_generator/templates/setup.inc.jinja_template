/*#-
This template file is distributed under the MIT License. See LICENSE.md for details.
#*/

/*(- generation_notice )*/

#include "../common.h"
#include "../functions.h"

/* LFSR generator */

uint64_t get_next_lfsr(uint32_t iteration_count) {
  for (uint32_t iteration = 0; iteration < iteration_count; ++iteration)
    lfsr = (lfsr >> 1) | ((((lfsr >> 1) ^ (lfsr >> 2)) & 1) << 63);
  return lfsr;
}

_Static_assert(sizeof(uint8_t) == 1, "A type with size == 1 is required.");
void regenerate_the_randomized_state(void) {
  for (uint32_t offset = 0; offset < /*( generated_byte_count )*/; ++offset)
    randomized_state.bytes[offset] = (uint8_t) get_next_lfsr(8);
}

// Following `setup_${TEST_NAME}` functions are simple wrappers around
// assembly-written `execute_${TEST_NAME}` counterparts. All they do is
// update (+ print to stdout) the randomized state and then call the wrapped
// test inside a `setjmp`-`longjmp` pair.
//
// These are only applicable for argument tests

/*{ for name, arguments in argument_functions.items() -}*/
void execute_/*( name )*/(void);
void setup_/*( name )*/(void) {
  regenerate_the_randomized_state();

  if (setjmp(jump_buffer) == 0) {
    execute_/*( name )*/();
    longjmp(jump_buffer, 1);
  }
}

/*{ endfor -}*/

void put_current_cpu_state_into_the_printable_location_1(void);

// Following `setup_${TEST_NAME}` functions are responsible for setting up
// return value tests.
//
// It calls the corresponding `test_${TEST_NAME}` function, after which it
// preserves all the after-call information it possibly can into printable
// locations.

/*{ for name, return_value_type in return_value_functions.items() -}*/
void setup_/*( name )*/(void) {
  regenerate_the_randomized_state();

  if (setjmp(jump_buffer) == 0) {
    typedef /*( return_value_type )*/ return_value_type;

    // Call the tested function.
    return_value_type returned = test_/*( name )*/();

    // Save the state right after the call.
    put_current_cpu_state_into_the_printable_location_1();

    // Write the pointer to the received values into a safe location,
    *(return_value_type **) printable_locations[2].words = &returned;

    // Then write the value to it as well.
    *(return_value_type *) (printable_locations[2].words + 1) = returned;

    longjmp(jump_buffer, 1);
  }
}

/*{ endfor }*/
