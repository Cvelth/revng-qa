#pragma once
/*( _ )*/

/*#-
This template file is distributed under the MIT License. See LICENSE.md for details.
#*/

/*(- generation_notice )*/

/**
 * Due to not wanting to lock ourselves into a single compiler ecosystem, we
 * are not able to rely on the compiler-specific data type logic, which leads
 * to having to generate a "universal" solution based on the data we already
 * have within the generator script.
 */

#ifdef __SIZEOF_INT128__
#define INT128_IS_SCALAR 1
#else
#define INT128_IS_SCALAR 0
#endif

// Using `1` and `0`s instead of `true`/`false` for initialization of `_Bool`s
// because of inconsistencies in how different compilers handle `stdbool.h`
// header.

#define IS_SCALAR(TYPE, VALUE) \
  _Generic((VALUE), \
    /*{- for type in supported_primitives }*/
           /*( type )*/: 1, \
           /*( type )*/ *: 1, \
    /*{- endfor }*/
    /*{- for name, fields in structs.items() }*/
           /*( name )*/: 0, \
           /*( name )*/ *: 1, \
    /*{- endfor }*/
    /*{- for name, fields in packed_structs.items() }*/
           /*( name )*/: 0, \
           /*( name )*/ *: 1, \
    /*{- endfor }*/
           INT128_T: INT128_IS_SCALAR, \
           INT128_T *: 1, \
           UINT128_T: INT128_IS_SCALAR, \
           UINT128_T *: 1, \
           void *: 1)

#define IS_PACKED(TYPE) (_Alignof(TYPE) == 1 && sizeof(TYPE) != 1)

#define ARGUMENT_SIZE_LIMIT(TYPE, VALUE) \
  (sizeof(void *) * (IS_SCALAR(TYPE, VALUE) ? MaximumGPRsPerScalarArgument : MaximumGPRsPerAggregateArgument))
#define RETURN_VALUE_SIZE_LIMIT(TYPE, VALUE) \
  (sizeof(void *) * (IS_SCALAR(TYPE, VALUE) ? MaximumGPRsPerScalarReturnValue : MaximumGPRsPerAggregateReturnValue))

